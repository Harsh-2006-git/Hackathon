<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AI-Powered Crowd Counter</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: "Arial", sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
      }

      .container {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        border-radius: 20px;
        padding: 30px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        max-width: 1000px;
        width: 100%;
      }

      h1 {
        text-align: center;
        color: white;
        margin-bottom: 30px;
        font-size: 2.5em;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      .camera-container {
        position: relative;
        margin-bottom: 30px;
        border-radius: 15px;
        overflow: hidden;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      }

      #video {
        width: 100%;
        height: 480px;
        object-fit: cover;
        display: block;
      }

      #canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
      }

      .controls {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-bottom: 30px;
        flex-wrap: wrap;
      }

      button {
        background: linear-gradient(45deg, #ff6b6b, #ee5a52);
        color: white;
        border: none;
        padding: 15px 30px;
        border-radius: 50px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      }

      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
      }

      button:disabled {
        background: linear-gradient(45deg, #999, #777);
        cursor: not-allowed;
        transform: none;
      }

      .stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin-bottom: 20px;
      }

      .stat-card {
        background: rgba(255, 255, 255, 0.15);
        padding: 20px;
        border-radius: 15px;
        text-align: center;
        backdrop-filter: blur(5px);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .stat-number {
        font-size: 2.5em;
        font-weight: bold;
        color: #fff;
        margin-bottom: 10px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      .stat-label {
        color: rgba(255, 255, 255, 0.8);
        font-size: 1.1em;
      }

      .settings {
        background: rgba(255, 255, 255, 0.1);
        padding: 20px;
        border-radius: 15px;
        margin-bottom: 20px;
        backdrop-filter: blur(5px);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .settings h3 {
        color: white;
        margin-bottom: 15px;
        font-size: 1.3em;
      }

      .setting-item {
        display: flex;
        align-items: center;
        margin-bottom: 15px;
        color: rgba(255, 255, 255, 0.9);
      }

      .setting-item label {
        margin-right: 15px;
        min-width: 150px;
      }

      .setting-item input,
      .setting-item select {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.3);
        color: white;
        padding: 8px 12px;
        border-radius: 5px;
        flex: 1;
      }

      .detection-info {
        background: rgba(255, 255, 255, 0.1);
        padding: 20px;
        border-radius: 15px;
        margin-top: 20px;
        backdrop-filter: blur(5px);
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .detection-info h3 {
        color: white;
        margin-bottom: 15px;
        font-size: 1.3em;
      }

      .detection-info p {
        color: rgba(255, 255, 255, 0.8);
        line-height: 1.6;
        margin-bottom: 10px;
      }

      .status {
        text-align: center;
        padding: 15px;
        border-radius: 10px;
        margin-bottom: 20px;
        font-weight: bold;
      }

      .status.loading {
        background: rgba(255, 193, 7, 0.2);
        color: #ffc107;
        border: 1px solid rgba(255, 193, 7, 0.3);
      }

      .status.ready {
        background: rgba(40, 167, 69, 0.2);
        color: #28a745;
        border: 1px solid rgba(40, 167, 69, 0.3);
      }

      .status.error {
        background: rgba(220, 53, 69, 0.2);
        color: #dc3545;
        border: 1px solid rgba(220, 53, 69, 0.3);
      }

      .algorithm-info {
        background: rgba(255, 255, 255, 0.05);
        padding: 15px;
        border-radius: 10px;
        margin-top: 10px;
        color: rgba(255, 255, 255, 0.7);
        font-size: 0.9em;
      }

      @media (max-width: 768px) {
        .container {
          padding: 20px;
        }

        h1 {
          font-size: 2em;
        }

        #video {
          height: 300px;
        }

        .controls {
          flex-direction: column;
          align-items: center;
        }

        button {
          width: 100%;
          max-width: 300px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>ü§ñ AI Crowd Counter</h1>

      <div id="status" class="status loading">Loading AI models...</div>

      <div class="camera-container">
        <video id="video" autoplay muted playsinline></video>
        <canvas id="canvas"></canvas>
      </div>

      <div class="controls">
        <button id="startBtn">Start Detection</button>
        <button id="stopBtn" disabled>Stop Detection</button>
        <button id="resetBtn">Reset Counter</button>
        <button id="calibrateBtn">Calibrate</button>
      </div>

      <div class="stats">
        <div class="stat-card">
          <div class="stat-number" id="currentCount">0</div>
          <div class="stat-label">People Detected</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="confidence">0%</div>
          <div class="stat-label">Confidence</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="maxCount">0</div>
          <div class="stat-label">Peak Count</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="fps">0</div>
          <div class="stat-label">FPS</div>
        </div>
      </div>

      <div class="settings">
        <h3>‚öôÔ∏è Detection Settings</h3>
        <div class="setting-item">
          <label>Sensitivity:</label>
          <input
            type="range"
            id="sensitivity"
            min="0.1"
            max="0.9"
            step="0.1"
            value="0.5"
          />
          <span id="sensitivityValue">0.5</span>
        </div>
        <div class="setting-item">
          <label>Min Person Size:</label>
          <input
            type="range"
            id="minSize"
            min="20"
            max="100"
            step="10"
            value="40"
          />
          <span id="minSizeValue">40px</span>
        </div>
        <div class="setting-item">
          <label>Detection Mode:</label>
          <select id="detectionMode">
            <option value="hybrid">Hybrid (Motion + Shape)</option>
            <option value="motion">Motion Only</option>
            <option value="shape">Shape Only</option>
            <option value="background">Background Subtraction</option>
          </select>
        </div>
      </div>

      <div class="detection-info">
        <h3>üîç How It Works</h3>
        <p>
          <strong>Advanced Computer Vision:</strong> Uses multiple algorithms
          including background subtraction, contour detection, and optical flow
          analysis.
        </p>
        <p>
          <strong>Real-time Processing:</strong> Processes video frames at 10-15
          FPS for accurate people counting.
        </p>
        <p>
          <strong>Adaptive Thresholding:</strong> Automatically adjusts to
          lighting conditions and camera position.
        </p>
        <p>
          <strong>Noise Filtering:</strong> Eliminates false positives from
          shadows, reflections, and small movements.
        </p>

        <div class="algorithm-info">
          <strong>Current Algorithm:</strong>
          <span id="currentAlgorithm">Initializing...</span><br />
          <strong>Processing Time:</strong> <span id="processingTime">0ms</span
          ><br />
          <strong>Background Model:</strong>
          <span id="backgroundStatus">Learning...</span>
        </div>
      </div>
    </div>

    <script>
      class AdvancedCrowdCounter {
        constructor() {
          this.video = document.getElementById("video");
          this.canvas = document.getElementById("canvas");
          this.ctx = this.canvas.getContext("2d");
          this.isDetecting = false;
          this.backgroundModel = null;
          this.previousFrame = null;
          this.detectionInterval = null;
          this.frameCount = 0;
          this.lastTime = Date.now();

          this.settings = {
            sensitivity: 0.5,
            minSize: 40,
            detectionMode: "hybrid",
          };

          this.stats = {
            current: 0,
            max: 0,
            confidence: 0,
            fps: 0,
          };

          this.detectedPeople = [];
          this.backgroundFrames = [];
          this.learningRate = 0.05;

          this.initializeCamera();
          this.setupEventListeners();
        }

        async initializeCamera() {
          try {
            const stream = await navigator.mediaDevices.getUserMedia({
              video: {
                width: { ideal: 1280 },
                height: { ideal: 720 },
                facingMode: "environment",
              },
            });

            this.video.srcObject = stream;
            this.video.addEventListener("loadedmetadata", () => {
              this.canvas.width = this.video.videoWidth;
              this.canvas.height = this.video.videoHeight;
              this.updateStatus(
                "ready",
                "Camera ready - Click Start Detection"
              );
              this.initializeBackgroundModel();
            });
          } catch (error) {
            console.error("Camera access error:", error);
            this.updateStatus(
              "error",
              "Camera access denied. Please allow camera access and refresh."
            );
          }
        }

        initializeBackgroundModel() {
          // Create initial background model
          this.backgroundModel = new ImageData(
            this.canvas.width,
            this.canvas.height
          );
          document.getElementById("backgroundStatus").textContent =
            "Initializing...";
        }

        setupEventListeners() {
          document
            .getElementById("startBtn")
            .addEventListener("click", () => this.startDetection());
          document
            .getElementById("stopBtn")
            .addEventListener("click", () => this.stopDetection());
          document
            .getElementById("resetBtn")
            .addEventListener("click", () => this.resetStats());
          document
            .getElementById("calibrateBtn")
            .addEventListener("click", () => this.calibrateBackground());

          // Settings listeners
          document
            .getElementById("sensitivity")
            .addEventListener("input", (e) => {
              this.settings.sensitivity = parseFloat(e.target.value);
              document.getElementById("sensitivityValue").textContent =
                e.target.value;
            });

          document.getElementById("minSize").addEventListener("input", (e) => {
            this.settings.minSize = parseInt(e.target.value);
            document.getElementById("minSizeValue").textContent =
              e.target.value + "px";
          });

          document
            .getElementById("detectionMode")
            .addEventListener("change", (e) => {
              this.settings.detectionMode = e.target.value;
              document.getElementById("currentAlgorithm").textContent =
                this.getAlgorithmName();
            });
        }

        getAlgorithmName() {
          const modes = {
            hybrid: "Hybrid Motion + Shape Detection",
            motion: "Optical Flow Motion Detection",
            shape: "Contour Shape Detection",
            background: "Background Subtraction",
          };
          return modes[this.settings.detectionMode] || "Unknown";
        }

        startDetection() {
          this.isDetecting = true;
          document.getElementById("startBtn").disabled = true;
          document.getElementById("stopBtn").disabled = false;
          this.updateStatus("ready", "AI Detection Active");
          document.getElementById("currentAlgorithm").textContent =
            this.getAlgorithmName();

          // Start detection loop
          this.detectionLoop();
        }

        stopDetection() {
          this.isDetecting = false;
          document.getElementById("startBtn").disabled = false;
          document.getElementById("stopBtn").disabled = true;
          this.updateStatus("ready", "Detection Stopped");

          if (this.detectionInterval) {
            clearInterval(this.detectionInterval);
          }
        }

        detectionLoop() {
          if (!this.isDetecting) return;

          const startTime = performance.now();

          // Get current frame
          const frame = this.getCurrentFrame();
          if (!frame) {
            setTimeout(() => this.detectionLoop(), 100);
            return;
          }

          // Detect people based on selected mode
          let detectedPeople = [];

          switch (this.settings.detectionMode) {
            case "hybrid":
              detectedPeople = this.hybridDetection(frame);
              break;
            case "motion":
              detectedPeople = this.motionDetection(frame);
              break;
            case "shape":
              detectedPeople = this.shapeDetection(frame);
              break;
            case "background":
              detectedPeople = this.backgroundSubtraction(frame);
              break;
          }

          // Update background model
          this.updateBackgroundModel(frame);

          // Filter and validate detections
          const validPeople = this.filterDetections(detectedPeople);

          // Update statistics
          this.updateStats(
            validPeople.length,
            this.calculateConfidence(validPeople)
          );

          // Draw results
          this.drawDetections(validPeople);

          // Update performance metrics
          const endTime = performance.now();
          document.getElementById("processingTime").textContent = `${Math.round(
            endTime - startTime
          )}ms`;

          // Update FPS
          this.updateFPS();

          // Store current frame for next iteration
          this.previousFrame = frame;

          // Continue detection loop
          setTimeout(() => this.detectionLoop(), 100); // ~10 FPS
        }

        getCurrentFrame() {
          if (this.video.readyState !== 4) return null;

          const tempCanvas = document.createElement("canvas");
          const tempCtx = tempCanvas.getContext("2d");
          tempCanvas.width = this.video.videoWidth;
          tempCanvas.height = this.video.videoHeight;

          tempCtx.drawImage(this.video, 0, 0);
          return tempCtx.getImageData(
            0,
            0,
            tempCanvas.width,
            tempCanvas.height
          );
        }

        hybridDetection(frame) {
          // Combine motion and shape detection
          const motionPeople = this.motionDetection(frame);
          const shapePeople = this.shapeDetection(frame);

          // Merge detections
          const combined = [...motionPeople, ...shapePeople];
          return this.mergeSimilarDetections(combined);
        }

        motionDetection(frame) {
          if (!this.previousFrame) return [];

          const motionMap = this.calculateMotion(frame, this.previousFrame);
          const contours = this.findContours(motionMap);

          return contours.filter(
            (contour) =>
              this.isPersonSizedContour(contour) &&
              this.hasPersonMotionPattern(contour)
          );
        }

        shapeDetection(frame) {
          // Convert to grayscale for edge detection
          const grayFrame = this.toGrayscale(frame);
          const edges = this.detectEdges(grayFrame);
          const contours = this.findContours(edges);

          return contours.filter(
            (contour) =>
              this.isPersonSizedContour(contour) && this.hasPersonShape(contour)
          );
        }

        backgroundSubtraction(frame) {
          if (!this.backgroundModel) return [];

          const foreground = this.subtractBackground(
            frame,
            this.backgroundModel
          );
          const contours = this.findContours(foreground);

          return contours.filter((contour) =>
            this.isPersonSizedContour(contour)
          );
        }

        calculateMotion(current, previous) {
          const motionData = new ImageData(current.width, current.height);
          const threshold = 30 * this.settings.sensitivity;

          for (let i = 0; i < current.data.length; i += 4) {
            const rDiff = Math.abs(current.data[i] - previous.data[i]);
            const gDiff = Math.abs(current.data[i + 1] - previous.data[i + 1]);
            const bDiff = Math.abs(current.data[i + 2] - previous.data[i + 2]);

            const motion = (rDiff + gDiff + bDiff) / 3;
            const intensity = motion > threshold ? 255 : 0;

            motionData.data[i] = intensity;
            motionData.data[i + 1] = intensity;
            motionData.data[i + 2] = intensity;
            motionData.data[i + 3] = 255;
          }

          return motionData;
        }

        toGrayscale(frame) {
          const grayData = new ImageData(frame.width, frame.height);

          for (let i = 0; i < frame.data.length; i += 4) {
            const gray =
              0.299 * frame.data[i] +
              0.587 * frame.data[i + 1] +
              0.114 * frame.data[i + 2];
            grayData.data[i] = gray;
            grayData.data[i + 1] = gray;
            grayData.data[i + 2] = gray;
            grayData.data[i + 3] = 255;
          }

          return grayData;
        }

        detectEdges(grayFrame) {
          // Simple Sobel edge detection
          const edges = new ImageData(grayFrame.width, grayFrame.height);
          const width = grayFrame.width;

          for (let y = 1; y < grayFrame.height - 1; y++) {
            for (let x = 1; x < width - 1; x++) {
              const idx = (y * width + x) * 4;

              // Get surrounding pixels
              const tl = grayFrame.data[((y - 1) * width + (x - 1)) * 4];
              const tm = grayFrame.data[((y - 1) * width + x) * 4];
              const tr = grayFrame.data[((y - 1) * width + (x + 1)) * 4];
              const ml = grayFrame.data[(y * width + (x - 1)) * 4];
              const mr = grayFrame.data[(y * width + (x + 1)) * 4];
              const bl = grayFrame.data[((y + 1) * width + (x - 1)) * 4];
              const bm = grayFrame.data[((y + 1) * width + x) * 4];
              const br = grayFrame.data[((y + 1) * width + (x + 1)) * 4];

              // Sobel operators
              const sobelX = tr + 2 * mr + br - (tl + 2 * ml + bl);
              const sobelY = bl + 2 * bm + br - (tl + 2 * tm + tr);

              const magnitude = Math.sqrt(sobelX * sobelX + sobelY * sobelY);
              const intensity = magnitude > 50 ? 255 : 0;

              edges.data[idx] = intensity;
              edges.data[idx + 1] = intensity;
              edges.data[idx + 2] = intensity;
              edges.data[idx + 3] = 255;
            }
          }

          return edges;
        }

        findContours(binaryImage) {
          const contours = [];
          const visited = new Array(
            binaryImage.width * binaryImage.height
          ).fill(false);

          for (let y = 0; y < binaryImage.height; y++) {
            for (let x = 0; x < binaryImage.width; x++) {
              const idx = y * binaryImage.width + x;
              if (!visited[idx] && binaryImage.data[idx * 4] > 128) {
                const contour = this.traceContour(binaryImage, x, y, visited);
                if (contour.length > 10) {
                  contours.push(contour);
                }
              }
            }
          }

          return contours;
        }

        traceContour(image, startX, startY, visited) {
          const contour = [];
          const stack = [{ x: startX, y: startY }];

          while (stack.length > 0) {
            const { x, y } = stack.pop();
            const idx = y * image.width + x;

            if (
              x < 0 ||
              x >= image.width ||
              y < 0 ||
              y >= image.height ||
              visited[idx]
            ) {
              continue;
            }

            if (image.data[idx * 4] < 128) continue;

            visited[idx] = true;
            contour.push({ x, y });

            // Add neighboring pixels
            for (let dy = -1; dy <= 1; dy++) {
              for (let dx = -1; dx <= 1; dx++) {
                stack.push({ x: x + dx, y: y + dy });
              }
            }
          }

          return contour;
        }

        isPersonSizedContour(contour) {
          const bounds = this.getContourBounds(contour);
          const width = bounds.maxX - bounds.minX;
          const height = bounds.maxY - bounds.minY;

          return (
            width >= this.settings.minSize &&
            height >= this.settings.minSize &&
            height > width * 0.8 && // Roughly vertical
            contour.length > 100
          );
        }

        hasPersonShape(contour) {
          const bounds = this.getContourBounds(contour);
          const aspectRatio =
            (bounds.maxY - bounds.minY) / (bounds.maxX - bounds.minX);

          // People are typically taller than they are wide
          return aspectRatio > 1.2 && aspectRatio < 4;
        }

        hasPersonMotionPattern(contour) {
          // Simple motion pattern check
          return contour.length > 50 && contour.length < 5000;
        }

        getContourBounds(contour) {
          let minX = Infinity,
            minY = Infinity;
          let maxX = -Infinity,
            maxY = -Infinity;

          for (const point of contour) {
            minX = Math.min(minX, point.x);
            minY = Math.min(minY, point.y);
            maxX = Math.max(maxX, point.x);
            maxY = Math.max(maxY, point.y);
          }

          return { minX, minY, maxX, maxY };
        }

        subtractBackground(frame, background) {
          const foreground = new ImageData(frame.width, frame.height);
          const threshold = 30;

          for (let i = 0; i < frame.data.length; i += 4) {
            const rDiff = Math.abs(frame.data[i] - background.data[i]);
            const gDiff = Math.abs(frame.data[i + 1] - background.data[i + 1]);
            const bDiff = Math.abs(frame.data[i + 2] - background.data[i + 2]);

            const diff = (rDiff + gDiff + bDiff) / 3;
            const intensity = diff > threshold ? 255 : 0;

            foreground.data[i] = intensity;
            foreground.data[i + 1] = intensity;
            foreground.data[i + 2] = intensity;
            foreground.data[i + 3] = 255;
          }

          return foreground;
        }

        updateBackgroundModel(frame) {
          if (!this.backgroundModel) {
            this.backgroundModel = new ImageData(frame.width, frame.height);
            for (let i = 0; i < frame.data.length; i++) {
              this.backgroundModel.data[i] = frame.data[i];
            }
            return;
          }

          // Update background with learning rate
          for (let i = 0; i < frame.data.length; i += 4) {
            this.backgroundModel.data[i] =
              this.backgroundModel.data[i] * (1 - this.learningRate) +
              frame.data[i] * this.learningRate;
            this.backgroundModel.data[i + 1] =
              this.backgroundModel.data[i + 1] * (1 - this.learningRate) +
              frame.data[i + 1] * this.learningRate;
            this.backgroundModel.data[i + 2] =
              this.backgroundModel.data[i + 2] * (1 - this.learningRate) +
              frame.data[i + 2] * this.learningRate;
          }

          document.getElementById("backgroundStatus").textContent = "Active";
        }

        mergeSimilarDetections(detections) {
          const merged = [];
          const used = new Set();

          for (let i = 0; i < detections.length; i++) {
            if (used.has(i)) continue;

            const group = [detections[i]];
            used.add(i);

            for (let j = i + 1; j < detections.length; j++) {
              if (used.has(j)) continue;

              if (this.contoursOverlap(detections[i], detections[j])) {
                group.push(detections[j]);
                used.add(j);
              }
            }

            merged.push(this.mergeContours(group));
          }

          return merged;
        }

        contoursOverlap(contour1, contour2) {
          const bounds1 = this.getContourBounds(contour1);
          const bounds2 = this.getContourBounds(contour2);

          return !(
            bounds1.maxX < bounds2.minX ||
            bounds2.maxX < bounds1.minX ||
            bounds1.maxY < bounds2.minY ||
            bounds2.maxY < bounds1.minY
          );
        }

        mergeContours(contours) {
          const merged = [];
          for (const contour of contours) {
            merged.push(...contour);
          }
          return merged;
        }

        filterDetections(detections) {
          // Remove detections that are too small, too large, or have wrong aspect ratio
          return detections.filter((contour) => {
            const bounds = this.getContourBounds(contour);
            const width = bounds.maxX - bounds.minX;
            const height = bounds.maxY - bounds.minY;
            const area = width * height;

            // Filter by size
            if (width < this.settings.minSize || height < this.settings.minSize)
              return false;
            if (
              width > this.canvas.width * 0.5 ||
              height > this.canvas.height * 0.8
            )
              return false;

            // Filter by aspect ratio (people are typically taller than wide)
            const aspectRatio = height / width;
            if (aspectRatio < 1.0 || aspectRatio > 5.0) return false;

            // Filter by area
            if (area < this.settings.minSize * this.settings.minSize * 2)
              return false;
            if (area > this.canvas.width * this.canvas.height * 0.3)
              return false;

            return true;
          });
        }

        calculateConfidence(detections) {
          if (detections.length === 0) return 0;

          let totalConfidence = 0;
          for (const detection of detections) {
            const bounds = this.getContourBounds(detection);
            const width = bounds.maxX - bounds.minX;
            const height = bounds.maxY - bounds.minY;
            const aspectRatio = height / width;

            // Confidence based on aspect ratio (people are ~1.5-3 times taller than wide)
            let confidence = 0;
            if (aspectRatio >= 1.5 && aspectRatio <= 3.0) {
              confidence = 0.8;
            } else if (aspectRatio >= 1.2 && aspectRatio <= 4.0) {
              confidence = 0.6;
            } else {
              confidence = 0.3;
            }

            // Adjust confidence based on size
            const sizeScore =
              Math.min(width / 100, 1.0) * Math.min(height / 150, 1.0);
            confidence *= sizeScore;

            totalConfidence += confidence;
          }

          return Math.round((totalConfidence / detections.length) * 100);
        }

        drawDetections(detections) {
          // Clear canvas
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          // Draw detection boxes
          this.ctx.strokeStyle = "#00ff00";
          this.ctx.lineWidth = 2;
          this.ctx.fillStyle = "rgba(0, 255, 0, 0.2)";

          detections.forEach((contour, index) => {
            const bounds = this.getContourBounds(contour);
            const x = bounds.minX;
            const y = bounds.minY;
            const width = bounds.maxX - bounds.minX;
            const height = bounds.maxY - bounds.minY;

            // Draw bounding box
            this.ctx.strokeRect(x, y, width, height);
            this.ctx.fillRect(x, y, width, height);

            // Draw person number
            this.ctx.fillStyle = "#ffffff";
            this.ctx.font = "bold 16px Arial";
            this.ctx.fillText(`${index + 1}`, x + 5, y + 20);

            // Draw center point
            const centerX = x + width / 2;
            const centerY = y + height / 2;
            this.ctx.beginPath();
            this.ctx.arc(centerX, centerY, 4, 0, 2 * Math.PI);
            this.ctx.fillStyle = "#ff0000";
            this.ctx.fill();

            this.ctx.fillStyle = "rgba(0, 255, 0, 0.2)";
          });

          // Draw detection area overlay
          this.ctx.strokeStyle = "#ffffff";
          this.ctx.lineWidth = 1;
          this.ctx.setLineDash([10, 10]);
          this.ctx.strokeRect(
            20,
            20,
            this.canvas.width - 40,
            this.canvas.height - 40
          );
          this.ctx.setLineDash([]);

          // Draw count display
          this.ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
          this.ctx.fillRect(10, 10, 200, 60);
          this.ctx.fillStyle = "#ffffff";
          this.ctx.font = "bold 24px Arial";
          this.ctx.fillText(`Count: ${detections.length}`, 20, 40);
          this.ctx.font = "14px Arial";
          this.ctx.fillText(`Confidence: ${this.stats.confidence}%`, 20, 60);
        }

        updateStats(count, confidence) {
          this.stats.current = count;
          this.stats.confidence = confidence;
          this.stats.max = Math.max(this.stats.max, count);

          document.getElementById("currentCount").textContent = count;
          document.getElementById("confidence").textContent = `${confidence}%`;
          document.getElementById("maxCount").textContent = this.stats.max;
        }

        updateFPS() {
          this.frameCount++;
          const now = Date.now();
          const elapsed = now - this.lastTime;

          if (elapsed >= 1000) {
            this.stats.fps = Math.round(this.frameCount / (elapsed / 1000));
            document.getElementById("fps").textContent = this.stats.fps;
            this.frameCount = 0;
            this.lastTime = now;
          }
        }

        calibrateBackground() {
          if (this.isDetecting) {
            this.updateStatus(
              "ready",
              "Please stop detection before calibrating"
            );
            return;
          }

          this.updateStatus("loading", "Calibrating background model...");

          // Capture several frames for better background model
          let framesCaptured = 0;
          const totalFrames = 10;
          this.backgroundFrames = [];

          const captureFrame = () => {
            const frame = this.getCurrentFrame();
            if (frame) {
              this.backgroundFrames.push(frame);
              framesCaptured++;

              if (framesCaptured < totalFrames) {
                setTimeout(captureFrame, 200);
              } else {
                this.createAverageBackground();
                this.updateStatus("ready", "Background calibration complete");
              }
            }
          };

          captureFrame();
        }

        createAverageBackground() {
          if (this.backgroundFrames.length === 0) return;

          const width = this.backgroundFrames[0].width;
          const height = this.backgroundFrames[0].height;
          this.backgroundModel = new ImageData(width, height);

          // Average all background frames
          for (let i = 0; i < this.backgroundModel.data.length; i += 4) {
            let rSum = 0,
              gSum = 0,
              bSum = 0;

            for (const frame of this.backgroundFrames) {
              rSum += frame.data[i];
              gSum += frame.data[i + 1];
              bSum += frame.data[i + 2];
            }

            this.backgroundModel.data[i] = rSum / this.backgroundFrames.length;
            this.backgroundModel.data[i + 1] =
              gSum / this.backgroundFrames.length;
            this.backgroundModel.data[i + 2] =
              bSum / this.backgroundFrames.length;
            this.backgroundModel.data[i + 3] = 255;
          }

          this.backgroundFrames = []; // Clear frames to save memory
          document.getElementById("backgroundStatus").textContent =
            "Calibrated";
        }

        resetStats() {
          this.stats = {
            current: 0,
            max: 0,
            confidence: 0,
            fps: 0,
          };

          document.getElementById("currentCount").textContent = "0";
          document.getElementById("confidence").textContent = "0%";
          document.getElementById("maxCount").textContent = "0";
          document.getElementById("fps").textContent = "0";

          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          this.frameCount = 0;
          this.lastTime = Date.now();
        }

        updateStatus(type, message) {
          const statusEl = document.getElementById("status");
          statusEl.className = `status ${type}`;
          statusEl.textContent = message;
        }
      }

      // Initialize the advanced crowd counter when page loads
      document.addEventListener("DOMContentLoaded", () => {
        new AdvancedCrowdCounter();
      });
    </script>
  </body>
</html>
